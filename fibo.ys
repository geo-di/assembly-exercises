# - Runtime instruction count: <10.000 for 2 small and 2 medium numbers# - I optimized the program using the peasant multiplication# implemented on the exercise, which is very efficient when# multiplying with large numbers. In this project specifically# it is needed to square the number given reaching up to 1000^2# - The sqrt subroutine is also used from the exercise and it is# optimized. Before it was using hardcoded numbers for divisions# by 2 or 4. This makes a lot of unnecessary instructions # and creates a bottleneck being the main reason for the number of# instructions. The way used to optimize this part was to implement# a right shift in a way similar to peasant multiplication iterating# each bit and using a mask. This way much less intructions are needed.# - Bit shifting right is more difficult than bit shifting left,# which can be done in one line with adding the number to itself.# (Multiplying by 2)# - In general, the code is optimized and the only part that could# impact the instruction count signifficantly is the sqrt subroutine.## Main code:##   Registers:#   rax: result (0 or non Fibo num)#   r11: array#   r12: array increment for now assuming 8#main:        #init registers    irmovq stack,%rsp   # stack pointer    irmovq stack,%rbp   # stack base address    irmovq $0, %rax     # returns 0 or a num that is not fibo    irmovq $8, %r12    irmovq $0 , %r13    #constant 0 for xorstart:        mrmovq (%r11), %rax # gets element from array    xorq %r13, %rax     # compares if it is zero    je end         rrmovq %rax, %rdi    rrmovq %rax, %rsi    call eff_mul        # returns x^2        irmovq $5, %rsi    call eff_mul        # returns 5*x^2        irmovq $4, %r9    addq %r9, %rdi      # rdi is now 5*x^2+4    rrmovq %rdi, %rdx   # saving value of rdi        call sqrt           # rdi is now sqrt(rdx)    rrmovq %rdi, %rsi    call eff_mul        # rdi is now squared        subq %rdx, %rdi    je increment_array  # if equal is true and continues with next num    irmovq $8, %r9    subq %r9, %rdx      # rdx is now 5*x^2-4    rrmovq %rdx, %rdi   # copying value of rdx to parameter rdi        call sqrt           # rdi is now sqrt(rdx)    rrmovq %rdi, %rsi    call eff_mul        # rdi is now squared    subq %rdi, %rdx    jne end             # if there are not equal this                        # means that both are false and                         # program ends returning the non fibo num        increment_array:    addq %r12, %r11    jmp startend:    halt.pos 0x300stack:                  # stack base address   .pos 0x700.align 8array:  #   Peasant binary multiplication #.pos 0x500eff_mul:    #   rdi = multiplicant    #   rsi = multiplier    #   r9 = temp    irmovq $0, %rcx     # result    irmovq $1, %r8     # maskloop:    rrmovq %rsi, %r9    subq %r8, %r9       # checks if mask > multiplier    jl eff_mul_end        rrmovq %rsi, %r9    andq %r8, %r9       # checks if the current bit is 0 or 1    je shifting        addq %rdi, %rcx     # if 1 adds the multiplicant to the sum    shifting:    addq %rdi, %rdi     # shifts the multiplicand to the right as in the pen and paper version    addq %r8, %r8       # shifts mask right    jmp loop    eff_mul_end:    rrmovq %rcx, %rdi   # passes result back to rdi    ret                        .pos 0x1100  sqrt:        #rdi = num    #rbx = parameter for rshift subroutine    #r8, r9, r10 temps    irmovq $0x400000, %rsi    #bit    irmovq $0, %rcx         #result    size_bit:    rrmovq %rsi, %r10    subq %rdi, %r10           jle while               # while bit > num        rrmovq %rsi, %rbx    call rshift         # bit >>= 2    call rshift    rrmovq %rbx, %rsi        jmp size_bit            # ehile loop ends    while:    andq %rsi, %rsi         # and is 0 only when rsi = 0    jne if                  # while bit != 0        rrmovq %rcx, %rdi       # passe result back to rdi    retif:    rrmovq %rcx, %r8    addq %rsi, %r8          # r8 = result + bit    rrmovq %rdi, %r9        # r9 = num    subq %r8, %r9    jl else_if              # if num >= r8        subq %r8, %rdi          # num -= r8    rrmovq %rcx, %rbx    call rshift             # result >>= 1    rrmovq %rbx, %rcx        addq %rsi, %rcx         # result += bit    jmp end_if              # ends if    else_if:                    # else statement    rrmovq %rcx, %rbx    call rshift             # result >>= 1    rrmovq %rbx, %rcx                            # ends ifend_if:    rrmovq %rsi, %rbx    call rshift         # bit >>= 2    call rshift    rrmovq %rbx, %rsi        jmp while               # ends while   .pos 0x1900    # this subroutine shifts the number given (rbx) to the right by one positionrshift:    # rbx = num    irmovq $0 , %r13     # temp result    irmovq $2 , %r8     # mask    irmovq $1 , %r9     # position    check_bit:        rrmovq %rbx, %r10    subq %r8, %r10    jl end_rshift       # checks if mask > num    rrmovq %rbx, %r10    andq %r8, %r10    je increase_pos     # checks if num bit is 1 according to mask        addq %r9, %r13      # if yes adds a bit in position    increase_pos:    addq %r8, %r8       # shifts left mask    addq %r9, %r9       # shifts left position    jmp check_bit    end_rshift:    rrmovq %r13, %rbx    ret